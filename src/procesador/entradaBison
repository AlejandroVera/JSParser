/* Analizador ascendente */
%language "Java"
%name-prefix "AnalizadorAsc"
%define parser_class_name "AnalizadorAsc"
%define package procesador;
%define stype "Parametros"
%define public

%code imports {
import java.io.File;
import java.io.IOException;
}

/* Bison Declarations */
%token PUNTOYCOMA NEWLINE IF SWITCH CASE 
%token BREAK NEW ARRAY FUNCTION DOCWRITE
%token VAR PROMPT RETURN
%token OPARITMETICO	OPRELACIONAL OPASIGNACION OPESPECIAL
%token OPLOGICO CORCHETEAB CORCHETECE PARENTESISAB
%token PARENTESISCE LLAVEAB LLAVECE COMA DOSPUNTOS
%token <Integer> ENTERO
%token <String> CADENA
%token <Parametros> IDENTIFICADOR
%type <Parametros> P P1 P2 P3 P4 P5 P6 P7 N H J Z 

/* Grammar follows */
%%
X : A
;

A : S D A
| D
;

D : NEWLINE
| PUNTOYCOMA
;


S : V
| F
| I
| W
| P6
;

V : T IDENTIFICADOR { Procesador.lexico.setEstadoDecV(false); }
;

T : VAR { Procesador.lexico.setEstadoDecV(true); }
;

P : Z { $$.nParam = $1.nParam; }
| { $$.nParam = 0; }
;

Z : P5 { $$.nParam = 1; }
| P5 COMA Z { $$.nParam = $3.nParam + 1; }
;

P6 : IDENTIFICADOR OPASIGNACION N { 
	if($3.tipo != TipoParam.ENTERO && $3.tipo != TipoParam.VECTOR ) 
		Procesador.errores.addError("Tipo incompatible");
	if($1.tipo == TipoParam.VECTOR || $1.tipo == TipoParam.FUNCION)
		Procesador.errores.addError("Error en la asignacion: tipo incompatible"); 
	$1.tipo = $3.tipo;
	$$.tipo = $1.tipo; }
| P7 { $$.tipo = $1.tipo; }
;

P7 : P7 OPLOGICO P5 { 
	if(!($1.tipo == $3.tipo && $1.tipo == TipoParam.ENTERO)) 
		Procesador.errores.addError("Tipos de datos no validos para operador logico");
	$$.tipo = TipoParam.ENTERO; }
| P5 { $$.tipo = $1.tipo; }
;

P5 : P5 OPRELACIONAL P4 { 
	if(!($1.tipo == $3.tipo && $1.tipo == TipoParam.ENTERO)) 
		Procesador.errores.addError("Tipos de datos no validos para operador relacional");
	$$.tipo = TipoParam.ENTERO; }
| P4 { $$.tipo = $1.tipo; }
;

P4 : P4 OPARITMETICO P3 { 
	if(!($1.tipo == $3.tipo && $1.tipo == TipoParam.ENTERO))
		Procesador.errores.addError("Tipos de datos no validos para operador aritmetico");
	$$.tipo = TipoParam.ENTERO; }
| P3 { $$.tipo = $1.tipo; }
;

P3 : OPESPECIAL P2 { 
	if($2.tipo != TipoParam.ENTERO) 
		Procesador.errores.addError("Tipos de datos no validos para operador de incremento"); 
	$$.tipo = TipoParam.ENTERO; }
| P2 { $$.tipo = $1.tipo; }
;

P2 : PARENTESISAB P6 PARENTESISCE { $$.tipo = $2.tipo; }
| P1 { $$.tipo = $1.tipo; }
;

P1 : IDENTIFICADOR PARENTESISAB P PARENTESISCE { 
	if(!Procesador.tablaSimbolos.buscarFuncionTS($1.nombre, $3.nParam)) 
		Procesador.errores.addError("Funcion no definida"); 
	$$.tipo = TipoParam.ENTERO; }
| IDENTIFICADOR CORCHETEAB P6 CORCHETECE { 
	if($1.tipo == TipoParam.NULO) 
		Procesador.errores.addError("Variable no definida");
	if($1.tipo != TipoParam.VECTOR) 
		Procesador.errores.addError("La variable no es de tipo vector.");
	if($3.tipo != TipoParam.ENTERO) Procesador.errores.addError("Indice no es de tipo entero."); 
	$$.tipo = TipoParam.ENTERO; }
| IDENTIFICADOR { 
	if($1.tipo == TipoParam.ENTERO) 
		$$.tipo = TipoParam.ENTERO;
	else if($1.tipo == TipoParam.VECTOR) 
		$$.tipo = TipoParam.VECTOR;
	else if($1.tipo == TipoParam.NULO)
		Procesador.errores.addError("Tipo no definido");
	else 
		Procesador.errores.addError("Tipo no valido"); }
| PROMPT PARENTESISAB CADENA PARENTESISCE { $$.tipo = TipoParam.ENTERO; }
| DOCWRITE PARENTESISAB CADENA PARENTESISCE { $$.tipo = TipoParam.ENTERO; }
| ENTERO  { $$.tipo = TipoParam.ENTERO; }
;

N : P5 { $$.tipo = $1.tipo; }
| NEW ARRAY PARENTESISAB P6 PARENTESISCE { 
	if($4.tipo != TipoParam.ENTERO) 
		Procesador.errores.addError("Tamaño de vector debe ser entero"); 
	$$.tipo = TipoParam.VECTOR; }
;

I : IF PARENTESISAB P6 PARENTESISCE L S { 
	if($3.tipo != TipoParam.ENTERO) 
		Procesador.errores.addError("Condición debe ser entera"); }
;

W : SWITCH PARENTESISAB P6 PARENTESISCE L LLAVEAB C L LLAVECE { 
	if($3.tipo != TipoParam.ENTERO) 
		Procesador.errores.addError("Variable del Switch debe ser entera"); }
;

L : NEWLINE
| 
;

C : L CASE P6 DOSPUNTOS A D B { 
	if($3.tipo != TipoParam.ENTERO) 
		Procesador.errores.addError("Condición debe ser entera"); }
;

B : BREAK
| 
;

F : FUNCTION F2 { Procesador.lexico.setEstadoDecF(1); }
;

F2 : IDENTIFICADOR PARENTESISAB H L LLAVEAB A R L LLAVECE { 
	Procesador.lexico.setEstadoDecF(0); 
	Procesador.tablaSimbolos.borrarTabla();}
;

H : IDENTIFICADOR PARENTESISAB J  { 
	if(Procesador.lexico.getEstadoDecF() != 0) 
		Procesador.errores.addError("No se admite la declaración anidada de funciones."); 
	else if(Procesador.tablaSimbolos.buscarFuncionTS($1.nombre, $3.nParam))
		Procesador.errores.addError("Funcion ya definida"); 
	
	Procesador.tablaSimbolos.añadir($1.nombre,false,EntradaTS.TipoEntradaTS.FUNCION);
	Procesador.tablaSimbolos.crearTabla(); }
| IDENTIFICADOR PARENTESISAB PARENTESISCE  {
	Procesador.tablaSimbolos.añadir($1.nombre,false,EntradaTS.TipoEntradaTS.FUNCION);
	Procesador.tablaSimbolos.crearTabla();
	Procesador.lexico.setEstadoDecF(2); }
;

J : IDENTIFICADOR PARENTESISCE { $$.nParam=1; }
| IDENTIFICADOR COMA J { $$.nParam=$3.nParam+1; }
;

R : RETURN P6 { 
	if($2.tipo != TipoParam.ENTERO) 
		Procesador.errores.addError("Funcion debe devolver un entero"); }
| RETURN
| 
;

/* User functions */
%%




