/* Analizador ascendente */
%language "Java"
%name-prefix "AnalizadorAsc"
%define parser_class_name "AnalizadorAsc"
%define package procesador;
%define stype "Parametros"
%define public

%code imports {
import java.io.File;
import java.io.IOException;
}

/* Bison Declarations */
%token PUNTOYCOMA NEWLINE IF SWITCH CASE 
%token BREAK NEW ARRAY FUNCTION DOCWRITE
%token VAR PROMPT RETURN
%token OPARITMETICO	OPRELACIONAL OPASIGNACION OPESPECIAL
%token OPLOGICO CORCHETEAB CORCHETECE PARENTESISAB
%token PARENTESISCE LLAVEAB LLAVECE COMA DOSPUNTOS
%token <Integer> ENTERO
%token <String> CADENA
%token <Parametros> IDENTIFICADOR
%type <Parametros> P P1 P2 P3 P4 P5 P6 P7 N H J Z C1

/* Grammar follows */
%%
X : A
;

A : S1 A
| S1
;

S1 : S D
/*| S Con esto funciona a pesar de los conflictos!!*/
;

D : Q
| Q2
;


Q2 : PUNTOYCOMA

L : Q
| 
;

Q : NEWLINE
;
 
S : V
| F
| I
| W
| P6
;

V : T IDENTIFICADOR { 
	Procesador.lexico.setEstadoDecV(false);}
;

T : VAR { Procesador.lexico.setEstadoDecV(true); }
;

P : Z { $$.nParam = $1.nParam; }
| { $$.nParam = 0; }
;

Z : P5 { 
	$$.nParam = 1;
	if($1.tipo != TipoParam.ENTERO)
		Procesador.errores.addError("Parametros de las funciones deben ser enteros.",false); }
| P5 COMA Z { 
	$$.nParam = $3.nParam + 1;
	if($1.tipo != TipoParam.ENTERO)
		Procesador.errores.addError("Parametros de las funciones deben ser enteros.",false); }
;

P6 : IDENTIFICADOR OPASIGNACION N { 
	if($3.tipo != TipoParam.ENTERO && $3.tipo != TipoParam.VECTOR ) 
		Procesador.errores.addError("Tipo incompatible",false);
	if($1.tipo == TipoParam.VECTOR || $1.tipo == TipoParam.FUNCION)
		Procesador.errores.addError("Error en la asignacion: tipo incompatible",false); 
	$1.tipo = $3.tipo;
	EntradaTS ent;
	if((ent = Procesador.tablaSimbolos.setTipoVariable($1.nombre, $1.tipo)) != null)
		$1.entrada = ent;
	$$.tipo = $1.tipo; }
| P7 { $$.tipo = $1.tipo; }
;

P7 : P7 OPLOGICO P5 { 
	if(!($1.tipo == $3.tipo && $1.tipo == TipoParam.ENTERO)) 
		Procesador.errores.addError("Tipos de datos no validos para operador logico",false);
	$$.tipo = TipoParam.ENTERO; }
| P5 { $$.tipo = $1.tipo; }
;

P5 : P5 OPRELACIONAL P4 { 
	if(!($1.tipo == $3.tipo && $1.tipo == TipoParam.ENTERO)) 
		Procesador.errores.addError("Tipos de datos no validos para operador relacional",false);
	$$.tipo = TipoParam.ENTERO; }
| P4 { $$.tipo = $1.tipo; }
;

P4 : P4 OPARITMETICO P3 { 
	if(!($1.tipo == $3.tipo && $1.tipo == TipoParam.ENTERO))
		Procesador.errores.addError("Tipos de datos no validos para operador aritmetico",false);
	$$.tipo = TipoParam.ENTERO; }
| P3 { $$.tipo = $1.tipo; }
;

P3 : OPESPECIAL P2 { 
	if($2.tipo != TipoParam.ENTERO) 
		Procesador.errores.addError("Tipos de datos no validos para operador de incremento",false); 
	$$.tipo = TipoParam.ENTERO; }
| P2 { $$.tipo = $1.tipo; }
;

P2 : PARENTESISAB P6 PARENTESISCE { $$.tipo = $2.tipo; }
| P1 { $$.tipo = $1.tipo; }
;

P1 : IDENTIFICADOR PARENTESISAB P PARENTESISCE { 
	if(!Procesador.tablaSimbolos.buscarFuncionTS($1.nombre, $3.nParam)) 
		Procesador.errores.addError("Funcion no definida",false); 
	$$.tipo = TipoParam.ENTERO; }
| IDENTIFICADOR CORCHETEAB P6 CORCHETECE { 
	if($1.tipo == TipoParam.NULO) 
		Procesador.errores.addError("Variable no definida",false);
	if($1.tipo != TipoParam.VECTOR) 
		Procesador.errores.addError("La variable no es de tipo vector.", false);
	if($3.tipo != TipoParam.ENTERO) Procesador.errores.addError("Indice no es de tipo entero.",false); 
	$$.tipo = TipoParam.ENTERO; }
| IDENTIFICADOR { 
	if($1.tipo == TipoParam.ENTERO) 
		$$.tipo = TipoParam.ENTERO;
	else if($1.tipo == TipoParam.VECTOR) 
		$$.tipo = TipoParam.VECTOR;
	else if($1.tipo == TipoParam.NULO)
		Procesador.errores.addError("Tipo no definido",false);
	else 
		Procesador.errores.addError("Tipo no valido",false); }
| PROMPT PARENTESISAB P6 PARENTESISCE { if ($3.tipo!=TipoParam.CADENA) 
				Procesador.errores.addError("El parametro de prompt debe ser una cadena.",false); 
			$$.tipo = TipoParam.ENTERO; }
| DOCWRITE PARENTESISAB P6 PARENTESISCE { if ($3.tipo!=TipoParam.CADENA) 
				Procesador.errores.addError("El parametro de Document.write debe ser una cadena.",false); 
			  $$.tipo = TipoParam.ENTERO; }
| ENTERO  { $$.tipo = TipoParam.ENTERO; }
| CADENA  { $$.tipo = TipoParam.CADENA; }
;

N : P5 { $$.tipo = $1.tipo; }
| NEW ARRAY PARENTESISAB P6 PARENTESISCE { 
	if($4.tipo != TipoParam.ENTERO) 
		Procesador.errores.addError("Tamaño de vector debe ser entero",false); 
	$$.tipo = TipoParam.VECTOR; }
;

I : IF PARENTESISAB P6 PARENTESISCE L I2 { 
	if($3.tipo != TipoParam.ENTERO) 
		Procesador.errores.addError("Condición debe ser entera",false); }
;

I2 : S
|R
;

W : SWITCH PARENTESISAB P6 PARENTESISCE L LLAVEAB L C LLAVECE { 
	if($3.tipo != TipoParam.ENTERO) 
		Procesador.errores.addError("Variable del Switch debe ser entera",false); }
;


C : CASE C1 DOSPUNTOS A /* D */ L B C2
;

C1 : P6 { 
	if($1.tipo != TipoParam.ENTERO) 
		Procesador.errores.addError("Condición debe ser entera",false); }
;

C2 : C
|
;

B : BREAK L
| 
;

F : F2 H L LLAVEAB L AS LLAVECE { 
	Procesador.lexico.setEstadoDecF(0); 
	Procesador.tablaSimbolos.borrarTabla();}
;

F2 : FUNCTION { 
	if(Procesador.lexico.getEstadoDecF() != 0) 
		Procesador.errores.addError("No se admite la declaración anidada de funciones.",false); 
	Procesador.lexico.setEstadoDecF(1); }
;

H : IDENTIFICADOR PARENTESISAB J { 
	
	if(Procesador.tablaSimbolos.buscarFuncionTS($1.nombre, $3.nParam))
		Procesador.errores.addError("Funcion ya definida",false); 
	
	if($1.entrada == null)
		$1.entrada = Procesador.tablaSimbolos.añadir($1.nombre,true,EntradaTS.TipoEntradaTS.FUNCION);
	
	((Funcion)$1.entrada).addFuncion($3.nParam);
	
	Procesador.tablaSimbolos.crearTabla(); 
	Procesador.lexico.setEstadoDecF(2);
	for (String s : $3.listaP){
		Procesador.tablaSimbolos.añadir(s,false,EntradaTS.TipoEntradaTS.VARIABLE);
		Procesador.tablaSimbolos.setTipoVariable(s, TipoParam.ENTERO);
	}
	}
| IDENTIFICADOR PARENTESISAB PARENTESISCE  {
	Procesador.tablaSimbolos.añadir($1.nombre,false,EntradaTS.TipoEntradaTS.FUNCION);
	Procesador.tablaSimbolos.crearTabla();
	Procesador.lexico.setEstadoDecF(2); }
;

AS : A R L
| A L
| R L
;

J : IDENTIFICADOR PARENTESISCE { 
	$$.nParam=1; 
	$$.listaP.add($1.nombre); }
| IDENTIFICADOR COMA J {
	$$.nParam=$3.nParam+1;
	$1.tipo = TipoParam.ENTERO; 
	$3.listaP.add($1.nombre);
	$$.listaP = $3.listaP; }
;

R : RETURN P6 { 
	if($2.tipo != TipoParam.ENTERO) 
		Procesador.errores.addError("Funcion debe devolver un entero",false); }
| RETURN
;

/* User functions */
%%




